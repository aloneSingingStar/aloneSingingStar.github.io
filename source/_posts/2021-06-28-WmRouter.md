---
title: WmRouter
date: 2021-06-28 15:43:31
tags:
categories:
---

## ServiceLoader

### 使用步骤
* 初始化ServiceLoader
```JAVA
 ServiceLoader.lazyInit();
```

* 定义接口以及实现类，并添加@RouterService注解
```JAVA
public interface IEmvParamService {}

@RouterService(interfaces = IEmvParamService.class,key = ConfigServiceConstant.CONFIGSERVICE_EMVPARAM,singleton = true)
public class EmvParamService implements IEmvParamService {}
```
* 使用对应服务
```java
IEmvParamService service = Router.getService(IEmvParamService.class, ConfigServiceConstant.CONFIGSERVICE_EMVPARAM);
```
### 原理分析
<!-- more -->

1.编译期间，找到所有使用了@RouterService注解的类，使用APT技术生成初始化代码。
```java
package com.sankuai.waimai.router.generated.service;
public class ServiceInit_9dce1d5c4961fd1e5216033e23f0dd60 {
  public static void init() {
    ServiceLoader.put(IConfigParamService.class, "configService_config", ConfigParamService.class, true);
    ServiceLoader.put(IAcquirerIssuerService.class, "configService_acquirer_issuer", AcquirerIssuerService.class, false);
    ServiceLoader.put(IEmvParamService.class, "configService_emvparam", EmvParamService.class, true);
    ServiceLoader.put(IModuleInit.class, "init_config", ConfigInit.class, false);
  }
}
```

2.应用初始化调用ServiceLoader.lazyInit()时，使用反射调用com.sankuai.waimai.router.generated.service包下的类的init方法。
```java
private static final LazyInitHelper sInitHelper = new LazyInitHelper("ServiceLoader") {
        @Override
        protected void doInit() {
            try {
                // 反射调用Init类，避免引用的类过多，导致main dex capacity exceeded问题
		//SERVICE_LOADER_INIT=com.sankuai.waimai.router.generated.service.ServiceLoaderInit
		//INIT_METHOD = "init"
                Class.forName(Const.SERVICE_LOADER_INIT)
                        .getMethod(Const.INIT_METHOD)
                        .invoke(null);
                Debugger.i("[ServiceLoader] init class invoked");
            } catch (Exception e) {
                Debugger.fatal(e);
            }
        }
    };
```
3.ServiceLoader.put方法逻辑，ServiceLoader内部维护了2级HashMap，通过2级HashMap实现了如下绑定关系
1.第一级HashMap绑定接口与ServiceLoader实例
loader = new ServiceLoader(IEmvParamService.class);
map1(IEmvParamService.class,loader)
2.第二级HashMap则是由接口对应的loader实例去调用，完成key与ServiceImpl的绑定
loader.putImpl(key, implementClass, singleton)
map2("configService_emvparam",new ServiceImpl("configService_emvparam", EmvParamService.class, true))
```java
/**
     * 提供给InitClass使用的初始化接口
     *
     * @param interfaceClass 接口类
     * @param implementClass 实现类
     */
    public static void put(Class interfaceClass, String key, Class implementClass, boolean singleton) {
        ServiceLoader loader = SERVICES.get(interfaceClass);
        if (loader == null) {
            loader = new ServiceLoader(interfaceClass);
            SERVICES.put(interfaceClass, loader);
        }
        loader.putImpl(key, implementClass, singleton);
    }

private void putImpl(String key, Class implementClass, boolean singleton) {
        if (key != null && implementClass != null) {
            mMap.put(key, new ServiceImpl(key, implementClass, singleton));
        }
    }

private static final Map<Class, ServiceLoader> SERVICES = new HashMap<>();
private HashMap<String, ServiceImpl> mMap = new HashMap<>();
````

4.使用Router.getService(IEmvParamService.class, ConfigServiceConstant.CONFIGSERVICE_EMVPARAM);时先通过一级HashMap获取接口对应的ServiceLoader实例，再通过二级HashMap获取接口的实现类，然后通过ServiceLoader创建实现类的实例(使用反射创建，如果是单例，还会缓存到对象池中)
```java
public static <I, T extends I> T getService(Class<I> clazz, String key) {
        return ServiceLoader.load(clazz).get(key);
    }

public static <T> ServiceLoader<T> load(Class<T> interfaceClass) {
        sInitHelper.ensureInit();
        if (interfaceClass == null) {
            Debugger.fatal(new NullPointerException("ServiceLoader.load的class参数不应为空"));
            return EmptyServiceLoader.INSTANCE;
        }
        ServiceLoader service = SERVICES.get(interfaceClass);
        if (service == null) {
            synchronized (SERVICES) {
                service = SERVICES.get(interfaceClass);
                if (service == null) {
                    service = new ServiceLoader(interfaceClass);
                    SERVICES.put(interfaceClass, service);
                }
            }
        }
        return service;
    }

/**
     * 创建指定key的实现类实例，使用 {@link RouterProvider} 方法或无参数构造。对于声明了singleton的实现类，不会重复创建实例。
     *
     * @return 可能返回null
     */
    public <T extends I> T get(String key) {
        return createInstance(mMap.get(key), null);
    }    
```

5.List<IEmvParamService> allServices = Router.getAllServices(IEmvParamService.class)时，通过接口IEmvParamService.class从一级HashMap中获取对应的ServiceLoader实例,然后再遍历ServiceLoader实例中的二级HashMap的value。每一个value对应一个实例【注意，从putImpl的源码可知，虽然实现同一个接口，但是不同的实现一定要指定唯一的一个key,否则会覆盖二级HashMap中的value】
```java
public static <I, T extends I> List<T> getAllServices(Class<I> clazz) {
        return ServiceLoader.load(clazz).getAll();
    }

public <T extends I> List<T> getAll(IFactory factory) {
        Collection<ServiceImpl> services = mMap.values();
        if (services.isEmpty()) {
            return Collections.emptyList();
        }
        List<T> list = new ArrayList<>(services.size());
        for (ServiceImpl impl : services) {
            T instance = createInstance(impl, factory);
            if (instance != null) {
                list.add(instance);
            }
        }
        return list;
    }   
```